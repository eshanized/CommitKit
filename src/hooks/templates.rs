// Author: Eshan Roy
// SPDX-License-Identifier: MIT

//! Hook templates.

use crate::version;

/// Hook template type.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HookTemplate {
    CommitMsg,
    PrepareCommitMsg,
    PrePush,
}

impl HookTemplate {
    /// Get the hook filename.
    pub fn filename(&self) -> &'static str {
        match self {
            HookTemplate::CommitMsg => "commit-msg",
            HookTemplate::PrepareCommitMsg => "prepare-commit-msg",
            HookTemplate::PrePush => "pre-push",
        }
    }

    /// Get all available templates.
    pub fn all() -> &'static [HookTemplate] {
        &[
            HookTemplate::CommitMsg,
            HookTemplate::PrepareCommitMsg,
            HookTemplate::PrePush,
        ]
    }

    /// Generate the hook script.
    pub fn generate(&self) -> String {
        let version_str = version::VERSION;
        let header = format!(
            r#"#!/bin/sh
# CK Git Hook
# Generated by ck v{}
# Do not edit manually - regenerate with: ck hooks install

"#,
            version_str
        );

        let body = match self {
            HookTemplate::CommitMsg => {
                r#"# Validate commit message
COMMIT_MSG_FILE="$1"

# Run ck check on the commit message
ck check --ci "$COMMIT_MSG_FILE" 2>&1

EXIT_CODE=$?
if [ $EXIT_CODE -ne 0 ]; then
    echo ""
    echo "Commit message validation failed."
    echo "Fix the issues above or use --no-verify to skip."
    exit 1
fi
"#
            }
            HookTemplate::PrepareCommitMsg => {
                r#"# Prepare commit message
COMMIT_MSG_FILE="$1"
COMMIT_SOURCE="$2"
SHA1="$3"

# Skip if this is a merge, squash, or amend
if [ "$COMMIT_SOURCE" = "merge" ] || [ "$COMMIT_SOURCE" = "squash" ]; then
    exit 0
fi

# If file is empty or just comments, try to generate a message
if ! grep -v '^#' "$COMMIT_MSG_FILE" | grep -q '[^[:space:]]'; then
    # Try to generate a smart commit message
    GENERATED=$(ck smart --ci --non-interactive --dry-run 2>/dev/null)
    if [ -n "$GENERATED" ]; then
        # Prepend generated message, keeping existing comments
        echo "$GENERATED" > "$COMMIT_MSG_FILE.tmp"
        echo "" >> "$COMMIT_MSG_FILE.tmp"
        cat "$COMMIT_MSG_FILE" >> "$COMMIT_MSG_FILE.tmp"
        mv "$COMMIT_MSG_FILE.tmp" "$COMMIT_MSG_FILE"
    fi
fi
"#
            }
            HookTemplate::PrePush => {
                r#"# Pre-push validation
REMOTE="$1"
URL="$2"

# Read stdin for refs being pushed
while read LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    # Skip deletions
    if [ "$LOCAL_SHA" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Determine range to check
    if [ "$REMOTE_SHA" = "0000000000000000000000000000000000000000" ]; then
        # New branch
        RANGE="$LOCAL_SHA"
    else
        RANGE="$REMOTE_SHA..$LOCAL_SHA"
    fi

    # Validate commits in range
    ck check --ci "$RANGE" 2>&1

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ]; then
        echo ""
        echo "Push blocked: Some commits failed validation."
        echo "Fix the issues above or use --no-verify to skip."
        exit 1
    fi
done

exit 0
"#
            }
        };

        format!("{}{}", header, body)
    }

    /// Parse a hook name string.
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "commit-msg" => Some(HookTemplate::CommitMsg),
            "prepare-commit-msg" => Some(HookTemplate::PrepareCommitMsg),
            "pre-push" => Some(HookTemplate::PrePush),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hook_filename() {
        assert_eq!(HookTemplate::CommitMsg.filename(), "commit-msg");
        assert_eq!(HookTemplate::PrePush.filename(), "pre-push");
    }

    #[test]
    fn test_hook_generate() {
        let script = HookTemplate::CommitMsg.generate();
        assert!(script.starts_with("#!/bin/sh"));
        assert!(script.contains("ck"));
    }

    #[test]
    fn test_hook_all() {
        let all = HookTemplate::all();
        assert_eq!(all.len(), 3);
    }

    #[test]
    fn test_hook_from_str() {
        assert_eq!(
            HookTemplate::from_str("commit-msg"),
            Some(HookTemplate::CommitMsg)
        );
        assert_eq!(HookTemplate::from_str("unknown"), None);
    }
}
